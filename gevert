#!/bin/bash

read -d '' helpDoc <<"helpDoc"
NAME
    gevert -- reverts a file selected with `gick`

SYNOPSIS
    gevert [-hD] <substrings>...

DESCRIPTION
    Checksout the head version of a file selected with `gick` and the given
    <substrings>.

    For any file reverted a backup is created in /tmp/gevert/. The file
    location is printed as part of the script output.

    The script can also received through standard input a list of files
    to revert, one file per line. When using standard input all given
    <substrings> are ignored, no search is performed.

OPTIONS
    -h  Prints this help output.

    -D  Enables dry run mode and performs no changes to the workspace.
        Messages about files being reverted are still printed, and backup
        copies are still created.
helpDoc


# Error codes
error_invalidOptions=1
error_noParams=2
error_noMatch=3


# Options values
run='true'


# Options parsing
while getopts :hD option; do
	case $option in
 		h)
			# Print help
			if [[ -t 0 ]]; then
				echo "$helpDoc" | less
			else
				echo "$helpDoc"
			fi
			exit
			;;
		D)
			# Dry run mode
			run='false'
			;;
		?)
			echo "Invalid option: -$OPTARG" >&2
			exit $error_invalidOptions
			;;
	esac
done

shift $(( OPTIND - 1 ));


# Either piped content or parameters are required
usePiped='false'
if [[ ! -t 0 ]]; then
	usePiped='true'
	piped=$(cat)
elif [[ $# = 0 ]]; then
	echo 'No parameters given' >&2
	exit $error_noParams
fi

# Getting the list of files to use
if [[ $usePiped = true ]]; then
	fileList="$piped"
else
	fileList=$(gick -- "$@" 2>/dev/null)

	if [[ $? != 0 ]]; then
		echo 'No files found' >&2
		exit $error_noMatch
	fi
fi


# Generating a the data for backups
backupPath="/tmp/gevert/"
mkdir -p "$backupPath"

# Creating a time stamp for the file
# year, month, day, hour, minute, second
timeStamp=$(date +"%Y%m%d_%H%M%S")

# Reverting the files
IFS=$'\n'
for fileName in $fileList; do
	baseFileName=$(basename $fileName)
	backupFile="${backupPath}${timeStamp}_${baseFileName}_XXXX"
	backupFile=$(mktemp $backupFile)

	# Make a backup of the file if it exists
	if [[ -f $fileName ]]; then
		cp $fileName $backupFile
		echo "backup in '$backupFile'"
	fi

	# TODO
	# new added files (with a A status) need to be reset and removed
	# checkout fails because there is nothing to checkout
	[[ $run = 'true' ]] && git checkout HEAD -- "$fileName"
	echo "reverted '$fileName'"
done
unset IFS

