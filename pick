#!/bin/bash

# Prints, from the content piped in, the line or lines that contain in
# order all the strings given as parameters.

# Used without options only the first match is displayed, if the -a
# option is used all the matches are printed.

# Pick uses grep -E to search for the given patters, that means that regular
# expressions can be used. However, dots are treated specialy, being slashed
# so that they are searched as dots. Using the -d option will let dots pass
# unescaped to the grep command.

# If no arguments or no content is piped in the script will end
# with a non-zero value, samewise if no match is found in the content
# piped in.


# Error codes
error_noStdin=1
error_noParams=2
error_invalidOptions=3
error_invalidParams=4
error_noMatch=5

# Basic checks
if [[ -t 0 ]]; then
	echo 'No stdin given' >&2
	exit $error_noStdin
fi

if [[ $# = 0 ]]; then
	echo 'No parameters given' >&2
	exit $error_noParams
fi

# Options values
maxCount='--max-count 1'
ignoreCase='--ignore-case'
keepDots=false
debugSearch=false

# Options parsing
params=$(getopt acdS $*)
getoptStatus=$?
set -- $params

if [[ $getoptStatus != 0 ]]; then
	echo 'Invalid options' >&2
	exit $error_invalidOptions
fi

for param; do
	case "$param" in
		-a)
			# Display all matches
			maxCount=''
			shift
			;;
		-c)
			# Force to not ignore case
			ignoreCase=''
			shift
			;;
		-d)
			# Leave dots unescaped
			keepDots=true
			shift
			;;
		-S)
			# Display search string instead of results, for debugging
			debugSearch=true
			shift
			;;
		--)
			shift
			break
			;;
	esac
done

piped=$(cat)

# Check for smart case
echo "$@" | grep [A-Z] >/dev/null 2>/dev/null

if [[ $? = 0 ]]; then
	# Any capital case triggers not ignoring case
	ignoreCase=''
fi

search=''
wildcard='.*'
for param in $@; do
	
	if [[ $keepDots = false ]]; then
		# treat dots since they are usual in filenames
		param=${param/./\\.}
		
		# if for any reason we do want a dot, appending it with \ will turn it back
		param=${param/\\\\./.}
	fi
	
	# Append a wildcard between each param
	search=$search$param$wildcard
done

# Remove the trailing wildcard
search=${search%"$wildcard"}

# Bailing out for debugging
if [[ $debugSearch = true ]]; then
	echo $search
	exit
fi

# Piped needs to be between quotes as to not loose the newlines
matches=$(echo "$piped" | grep -E $ignoreCase $maxCount $search)

if [[ $? != 0 ]]; then
	echo 'No match found' >&2
	exit $error_noMatch
fi

echo "$matches"

