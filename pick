#!/bin/bash

read -d '' helpDoc <<"helpDoc"
NAME
    pick -- searches stdin for an ordered list of substrings

SYNOPSIS
    pick [-hacdS] <substring>...

DESCRIPTION
    Prints, from the content read from the standard input, the first line
    that contains in order all given <substring>s.
    
    If no arguments or no content is piped in, or if no matching line is
    found, the script will exit with a non zero value.
    
    Example:
    
        # Having a file that contains a list of fruits
        > cat fruits
        blood orange
        green apple
        tangerine
        
        > cat fruits | pick rang
        blood orange
        
        > cat fruits | pick reen ple
        green apple
        
        > cat fruits | pick rine tang
        # Output to stderr
        No match found
    
    By default if all <substring>s contain only lowercase letters the
    matching is done ignoring all case diferences. If any upper case is
    used in the <substring>s the command will automatically switch to
    consider cases. This behaviour can be overriden with the -c option,
    which will force the command to always consider cases.
    
    Pick uses grep with extended regular expressions to match the
    <substring>s, this means that regular expretions could be used as
    parameter to the command. However dots (.) are treated specially since
    it is a very common character in filenames. When passing dots the
    command will escape them from the final regular expression. This
    behaviour can be overriden with the -d option, which will leave dots
    unescaped.

OPTIONS
    -h  Prints this help output.
    
    -a  Displays all lines that match the search.
    
    -c  Forces the command to consider case differences.
    
    -d  Consider dots as part of a regular expression, instead of escaping
        them.
    
    -S  Prints the regular expression used to search for matches.
helpDoc


# Error codes
error_invalidOptions=1
error_noStdin=2
error_noParams=3
error_noMatch=4


# Options values
maxCountOption='--max-count 1'
ignoreCaseOption='--ignore-case'
keepDots='false'
debugSearch='false'


# Options parsing
while getopts hacdS option; do
	case $option in
 		h)
			# Print help
			if [[ -t 0 ]]; then
				echo "$helpDoc" | less
			else
				echo "$helpDoc"
			fi
			exit
			;;
		a)
			# Display all matches
			maxCountOption=''
			;;
		c)
			# Force to not ignore case
			ignoreCaseOption=''
			;;
		d)
			# Leave dots unescaped
			keepDots='true'
			;;
		S)
			# Display search string instead of results, for debugging
			debugSearch='true'
			;;
		?)
			exit $error_invalidOptions
			;;
	esac
done

shift $(( OPTIND - 1 ));


# Options validation
if [[ -t 0 ]]; then
	echo 'No stdin given' >&2
	exit $error_noStdin
fi

if [[ $# = 0 ]]; then
	echo 'No parameters given' >&2
	exit $error_noParams
fi


piped=$(cat)

# Check for smart case
echo "$@" | grep [A-Z] >/dev/null 2>/dev/null

if [[ $? = 0 ]]; then
	# Any capital case triggers not ignoring case
	ignoreCaseOption=''
fi

search=''
wildcard='.*'
for param in $@; do
	if [[ $keepDots = 'false' ]]; then
		# escape dots since they are usual in filenames
		param=${param/./\\.}
		
		# if for any reason we do want a dot, appending it with \ will
		# de-escape it
		param=${param/\\\\./.}
	fi
	
	# Append a wildcard between each param
	search=$search$param$wildcard
done

# Remove the trailing wildcard
search=${search%"$wildcard"}

# Printing out debug string
if [[ $debugSearch = 'true' ]]; then
	echo $search
fi

matches=$(echo "$piped" | grep -E $ignoreCaseOption $maxCountOption $search)

if [[ $? != 0 ]]; then
	echo 'No match found' >&2
	exit $error_noMatch
fi

echo "$matches"

