#!/bin/bash

read -d '' helpDoc <<"helpDoc"
NAME
    pick -- searches stdin for an ordered list of substrings

SYNOPSIS
    pick [-hacdS] <substring>...

DESCRIPTION
    Prints, from the content piped into the command, the first line that
    contains in order all given <substring>s.
    
    If no arguments or no content is piped in, or if no matching line is
    found, the script will exit with a non zero value.
    
    Example:
    
        # Having a file that contains a list of fruits
        > cat fruits
        blood orange
        green apple
        tangerine
        
        > cat fruits | pick rang
        blood orange
        
        > cat fruits | pick reen ple
        green apple
        
        > cat fruits | pick rine tang
        # Output to stderr
        No match found
    
    By default if all <substring>s contain only lowercase letters the
    matching is done ignoring all case diferences. If any upper case is
    used in the <substring>s the command will automatically switch to
    consider cases. This behaviour can be overriden with the -c option,
    which will force the command to always consider cases.
    
    Pick uses grep with extended regular expressions to match the
    <substring>s, this means that regular expretions could be used as
    parameter to the command. However dots (.) are treated specially since
    it is a very common character in filenames. When passing dots the
    command will escape them from the final regular expression. This
    behaviour can be overriden with the -d option, which will leave dots
    unescaped.

OPTIONS
    -h  Prints this help output.
    
    -a  Displays all lines that match the search.
    
    -c  Forces the command to consider case differences.
    
    -d  Consider dots as part of a regular expression, instead of escaping
        them.
    
    -S  Prints the regular expression used to search for matches and all
        matching lines.
helpDoc


# Error codes
error_noStdin=1
error_noParams=2
error_invalidOptions=3
error_noMatch=4

# Basic checks
if [[ -t 0 ]]; then
	echo 'No stdin given' >&2
	exit $error_noStdin
fi

if [[ $# = 0 ]]; then
	echo 'No parameters given' >&2
	exit $error_noParams
fi

# Options values
maxCount='--max-count 1'
ignoreCase='--ignore-case'
keepDots=false
debugSearch=false

# Options parsing
params=$(getopt acdS $*)
getoptStatus=$?
set -- $params

if [[ $getoptStatus != 0 ]]; then
	echo 'Invalid options' >&2
	exit $error_invalidOptions
fi

for param; do
	case "$param" in
		-a)
			# Display all matches
			maxCount=''
			shift
			;;
		-c)
			# Force to not ignore case
			ignoreCase=''
			shift
			;;
		-d)
			# Leave dots unescaped
			keepDots=true
			shift
			;;
		-S)
			# Display search string instead of results, for debugging
			debugSearch=true
			shift
			;;
		--)
			shift
			break
			;;
	esac
done

piped=$(cat)

# Check for smart case
echo "$@" | grep [A-Z] >/dev/null 2>/dev/null

if [[ $? = 0 ]]; then
	# Any capital case triggers not ignoring case
	ignoreCase=''
fi

search=''
wildcard='.*'
for param in $@; do
	
	if [[ $keepDots = false ]]; then
		# treat dots since they are usual in filenames
		param=${param/./\\.}
		
		# if for any reason we do want a dot, appending it with \ will turn it back
		param=${param/\\\\./.}
	fi
	
	# Append a wildcard between each param
	search=$search$param$wildcard
done

# Remove the trailing wildcard
search=${search%"$wildcard"}

# Bailing out for debugging
if [[ $debugSearch = true ]]; then
	echo $search
	exit
fi

# Piped needs to be between quotes as to not loose the newlines
matches=$(echo "$piped" | grep -E $ignoreCase $maxCount $search)

if [[ $? != 0 ]]; then
	echo 'No match found' >&2
	exit $error_noMatch
fi

echo "$matches"

