#!/bin/bash

read -d '' helpDoc <<"helpDoc"
NAME
    gtatus -- git status for machine consumption

SYNOPSIS
    gtatus [-hcsw]

DESCRIPTION
    Prints a sensible git status that can be consumed easily by other
    scripts.
    
    The status printed is based in the output of `git status -z` and will
    comply with the following in the default settings:
     * The status of one file is ouput by line, with the usual format of
       one leter for stage status, one leter for workspace status, one
       space, and the filename.
     * Filenames are not quoted regardless of the presence of spaces 
       within and no special characters are escaped.
     * No R status is ever printed, instead the status of both related
       files are printed each on its own line following the normal format.
     * When run from a subdirectory the filenames will be relative to it.

OPTIONS
    -h  Prints this help output.
    
    -c  Prints only the filenames, status are ommited.
    
    -s  Prints only files that have any status in stage.
    
    -w  Prints only files that have any status in the workspace.
helpDoc


# Error codes
error_invalidOptions=1


# Options values
cutStatusMode='false'
onlyStageStatus='false'
onlyWorkspaceStatus='false'


# Options parsing
while getopts hcws option; do
	case $option in
 		h)
			# Print help
			echo "$helpDoc"
			exit
			;;
		c)
			# Cut status from output
			cutStatusMode='true'
			;;
		s)
			# Only files with stage status
			onlyStageStatus='true'
			;;
		w)
			# Only files with workspace status
			onlyWorkspaceStatus='true'
			;;
		?)
			exit
			;;
	esac
done

shift $(( OPTIND - 1 ));


# Options validation

# If -s and -w are used, all status is printed
if [[ $onlyStageStatus = 'true' && $onlyWorkspaceStatus = 'true' ]]; then
	onlyStageStatus='false'
	onlyWorkspaceStatus='false'
fi


# Getting a clean status, separated by new lines
rawStatus=$(git status -z -- "$@" | xargs -0 -n 1)

relativePath=$(git rev-parse --show-cdup)


# TODO have a first loop that cleans the ouput from R status, and marks those
# lines for requery
# that way the second loop is cleaner by not having to handle that special case


nextIsRenamedFile='false'
IFS=$'\n'
for statusLine in $rawStatus; do
	# For renamed files, the current line is wholy the filename
	# Status is requested again to have the correct status of that file
	if [[ $nextIsRenamedFile = 'true' ]]; then
		# On very odd cases, a renamed file which was re-added, the status
		# of a specific file can actualy return two lines, for this case
		# we take just the first line
		fileName="$relativePath$statusLine"
		statusLine=$(git status -z -- "$fileName" | xargs -0 -n1 | head -n 1)
		nextIsRenamedFile='false'
	fi
	
	# Retrieve both status of the file
	stageStatus=${statusLine:0:1}
	workspaceStatus=${statusLine:1:1}
	fileName=${statusLine:3}
	
	# Handing special R status
	if [[ $stageStatus = 'R' ]]; then
		# R status is for renamed files, its a mess, and it means the next
		# line will contain ONLY the name of the file that was removed
		nextIsRenamedFile='true'
		
		# Current file needs to be requested again to get its correct status
		statusLine=$(git status -z -- "$relativePath$fileName")
		stageStatus=${statusLine:0:1}
		workspaceStatus=${statusLine:1:1}
		fileName=${statusLine:3}
	fi
	
	if [[ $onlyStageStatus = 'true' && $stageStatus = ' ' ]]; then
		continue
	fi
	
	if [[ $onlyWorkspaceStatus = 'true' && $workspaceStatus = ' ' ]]; then
		continue
	fi
	
	if [[ $cutStatusMode = 'true' ]]; then
		echo "$relativePath$fileName"
	else
		echo "$stageStatus$workspaceStatus $relativePath$fileName"
	fi
done
unset IFS


