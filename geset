#!/bin/bash

read -d '' helpDoc <<"helpDoc"
NAME
    geset -- reset a file selected with `gick`

SYNOPSIS
    geset [-hpaD]

DESCRIPTION
    Unstages files selected with `gick` and the given <substrings>.

    If <substrings> is comprised of a single dot "." the script will try to
    unstage all modified files present in the workspace.

    The script can also received through standard input a list of files
    to unstage, one file per line. When using standard input all given
    <substrings> are ignored, no search is performed.

OPTIONS
    -h  Prints this help output.

    -p  Uses the parameters given as paths, instead of performing a search.

    -a  Stages all files that match the search, instead of only the first
        one. This option is ignored if `-p` is used.

    -D  Enables dry run mode and performs no changes to the stage. Messages
        about files being unstaged are still printed.
helpDoc


# Error codes
error_invalidOptions=1
error_noParams=2
error_noMatch=3


# Options values
dotCaseOptions=''
gickOptions=''
usePlainPaths='false'
run='true'


# Options parsing
while getopts :hpaD option; do
	case $option in
 		h)
			# Print help
			if [[ -t 0 ]]; then
				echo "$helpDoc" | less
			else
				echo "$helpDoc"
			fi
			exit
			;;
		p)
			# Using plain paths
			usePlainPaths='true'
			;;
		[a])
			# Pass through to gick
			# all matches
			gickOptions+=" -$option"
			;;
		D)
			# Dry run mode
			run='false'
			dotCaseOptions+=" -$option"
			;;
		?)
			echo "Invalid option: -$OPTARG" >&2
			exit $error_invalidOptions
			;;
	esac
done

shift $(( OPTIND - 1 ));


# Piped content
usePiped='false'
if [[ ! -t 0 ]]; then
	usePiped='true'
	piped=$(cat)
elif [[ $# = 0 ]]; then
	echo 'No parameters given' >&2
	exit $error_noParams
fi

# Dot special case
if [[ $# = 1 && $1 = '.' ]]; then
	glist -cs | geset $dotCaseOptions
	exit $?
fi

# Getting the list of files to use
if [[ $usePiped = 'true' ]]; then
	# Use piped list
	fileList="$piped"
else
	if [[ $usePlainPaths = 'true' ]]; then
		# Moving params to filelist, separated by newlines
		fileList=$1
		shift
		for item in "$@"; do
			fileList+=$'\n'$item
		done
	else
		# Find the file with gick
		fileList=$(gick -s $gickOptions -- "$@" 2>/dev/null)

		if [[ $? != 0 ]]; then
			echo 'No files found' >&2
			exit $error_noMatch
		fi
	fi
fi


# Reseting the files
IFS=$'\n'
for fileName in $fileList; do
	# TODO filelist should contain only files with stage status
	# TODO If files are given here without stage status, print cannot reset
	[[ $run = 'true' ]] && git reset --quiet HEAD -- "$fileName"
	echo "reset '$fileName'"
done
unset IFS

