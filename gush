#!/bin/bash

read -d '' helpDoc <<"helpDoc"
NAME
    gush -- perform `git push` operations

SYNOPSIS
    gush [-hD] [--] [<substrings>...]

DESCRIPTION
    Performs automatically various common `git push` operations.

    When the current branch is tracking a remote branch:
      - Without any arguments the program will push into the tracking
        branch.
      - Otherwise a remote is selected with `gickr` and the given
        `<substrings>` and the program will push to a remote branch of the
        same name as the current.
      - The tracking information of the current branch is not changed.

    When the current branch is not tracking a remote branch:
      - Without any argments the program will push into a remote branch of
        the same name if the repository has a single remote. If the
        repository has more than one remote then arguments are mandatory
        to select a remote with `gickr` and the given `<substrings>`.
      - With arguments a remote is selected with `gickr` and the given
        <substrings>` and the program will push to a remote branch of the
        same name as the current.
      - The current branch will be set to track the remote brach to which
        it was pushed.

OPTIONS
    -h  Prints this help output and quits the program.

    -D  Enables dry run mode and performs no changes nor pushes. The
        `git push` command that would the run is printed instead.
helpDoc


# Error codes
error_invalidOptions=1
error_notInBranch=2
error_noSingleRemote=3
error_noRemoteMatch=4
error_remoteBranchExists=5


# Options defaults
run='true'


# Options parsing
while getopts :hD option; do
	case $option in
 		h)
			# Print help
			if [[ -t 0 ]]; then
				echo "$helpDoc" | less
			else
				echo "$helpDoc"
			fi
			exit 0
			;;
		D)
			# Dry run mode
			run='false'
			;;
		?)
			[[ -t 1 ]] && echo "Invalid option: -$OPTARG" >&2
			exit $error_invalidOptions
			;;
	esac
done
shift $(( OPTIND - 1 ));


# If headless nothing to do here
branchName=$(ginfo branch 2>/dev/null)
if [[ $? != 0 ]]; then
	echo 'Not in a branch' >&2
	exit $error_notInBranch
fi

# First check for the tracking branch
setUpstream=''
trackingBranch=$(ginfo tracking 2>/dev/null)
if [[ $? = 0 ]]; then
	# Tracking and no arguments, simply push
	if [[ $# = 0 ]]; then
		if [[ $run = 'true' ]]; then
			git push
		else
			echo git push
		fi
		exit 0
	fi
else
	# Having no tracking means we will set it
	setUpstream='--set-upstream'
fi

# Get what remote will be used
if [[ $# = 0 ]]; then
	remote=$(gickr 2>/dev/null)
	if [[ $? != 0 ]]; then
		echo 'No single remote found' >&2
		exit $error_noSingleRemote
	fi
else
	remote=$(gickr $@ 2>/dev/null)
	if [[ $? != 0 ]]; then
		echo 'No remote match found' >&2
		exit $error_noRemoteMatch
	fi
fi

# If the upstream will be set,
# check the branch does not exist remotely
if [[ $setUpstream != '' ]]; then
	remoteBranchName="$remote/$branchName"
	git branch -r | tr -d [:blank:] | grep "^$remoteBranchName$" >/dev/null
	if [[ $? = 0 ]]; then
		echo "Remote branch already exists '$remoteBranchName'" >&2
		exit $error_remoteBranchExists
	fi
fi

# All good so beam it up
if [[ $run = 'true' ]]; then
	git push "$setUpstream" "$remote" "$branchName"
else
	echo git push "$setUpstream" "$remote" "$branchName"
fi

