#!/bin/bash

read -d '' helpDoc <<"helpDoc"
NAME
    gadd - stages a file selected with `gick`

SYNOPSIS
    gadd [-hNaD] <substrings>...

DESCRIPTION
    Stages files selected with `gick` and the given <substrings>.

    Depending on the workspace status of each file these will be added or
    removed properly from stage.

    If <substrings> is comprised of a single dot "." the script will
    try to stage all modified files present in the workspace.

    The script can also received through standard input a list of files
    to stage, one file per line. In this case the paths are used as
    received, no search is performed with them.

OPTIONS
    -h  Prints this help output.

    -N  Stages untracked files with an intent-to-add state. Processed files
        will be staged with an empty marker so that later can be properly
        added. This state allows other commands, like giff, to properly
        work with these files. When using this option only untracked files
        will be processed, files with any other workspace status are
        ignored.

    -a  Stages all files that match the search.

    -D  Enables dry run mode and performs no changes to the stage. Messages
        about files being staged are still printed.
helpDoc


# Error codes
error_invalidOptions=1
error_noParams=2
error_noMatch=3


# Options values
dotCaseOptions=''
gickOptions=''
stageUntracked='false'
dryRun='false'


# Options parsing
while getopts :hNswaD option; do
	case $option in
 		h)
			# Print help
			if [[ -t 0 ]]; then
				echo "$helpDoc" | less
			else
				echo "$helpDoc"
			fi
			exit
			;;
		N)
			# Stage untracked files
			stageUntracked='true'
			dotCaseOptions+=" -$option"
			;;
		[a])
			# Pass through to gick
			# all matches
			gickOptions+=" -$option"
			;;
		D)
			# Dry run mode
			dryRun='true'
			dotCaseOptions+=' -$option'
			;;
		?)
			echo "Invalid option: -$OPTARG" >&2
			exit $error_invalidOptions
			;;
	esac
done

shift $(( OPTIND - 1 ));


# Options validation

# Either piped content or parameters are required
usePiped='false'
if [[ ! -t 0 ]]; then
	usePiped='true'
	piped=$(cat)
elif [[ $# = 0 ]]; then
	echo 'No parameters given' >&2
	exit $error_noParams
fi

# Single dot special case
if [[ $# = 1 && $1 = '.' ]]; then
	if [[ $stageUntracked = 'false' ]]; then
		fileList=$(glist -c)
	else
		# TODO when glist support status selection, replace bellow
		fileList=$(glist | grep "^.?" | cut -c 4-)
	fi

	echo "$fileList" | gadd $dotCaseOptions
	exit $?
fi


# Getting the list of files to use
if [[ $usePiped = 'true' ]]; then
	fileList="$piped"
else
	fileList=$(gick $gickOptions -- "$@" 2>/dev/null)

	if [[ $? != 0 ]]; then
		echo 'No files found' >&2
		exit $error_noMatch
	fi
fi

# Properly staging each file
IFS=$'\n'
for fileName in $fileList; do
	# Retrieve status of the file
	# TODO status could be provided by single call to glist

	# TODO what if file does not exists or has no status?
	# files through pipe in could not exist

	# TODO some cases of glist, deleted file from git but file still exists
	# is considered as D, and with a second line as untracked with ??
	# those files will have two lines of status in a single glist call
	# split them in those cases?
	# but seems to be the case only of a deleted file that was readded..
	# which is already odd. In those cases git add -N yields a MM status
	fileStatus=$(glist -- "$fileName")
	stageStatus=${fileStatus:0:1}
	workspaceStatus=${fileStatus:1:1}

	# Stage untracked will only add unstaged files
	if [[ $stageUntracked = 'true' ]]; then
		if [[ $workspaceStatus = '?' ]]; then
			git add -N "$fileName"
			echo "marked '$fileName'"
		else
			echo "Invalid stage status '$workspaceStatus' for '$fileName'" >&2
		fi
		continue
	fi

	# Normal files are added or removed acordingly
	case $workspaceStatus in
		' ')
			case $stageStatus in
				[MA])
					echo "Already staged '$fileName'" >&2
					;;
				[D])
					echo "Already removed '$fileName'" >&2
					;;
				esac
			;;
		[MA?])
			[[ $dryRun = 'false' ]] && git add "$fileName"
			echo "added '$fileName'"
			;;
		[D])
			[[ $dryRun = 'false' ]] && git rm --quiet "$fileName"
			echo "removed '$fileName'"
			;;
		*)
			echo "Unknown workspace status '$workspaceStatus' for '$fileName'" >&2
			echo 'No operation done' >&2
			;;
	esac
done
unset IFS

